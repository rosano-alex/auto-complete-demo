---
applyTo: '**'
---
# Unit Test MCP

## CRITICAL — Always use MCP tools

**NEVER** run test commands in a terminal (`jest`, `pytest`, `vitest`, `dotnet test`, `npm test`, etc.). Before calling `run_in_terminal` with any test command, **STOP** and use the MCP `run_tests` tool instead. No exceptions — not even for "quick validation".

**NEVER** manually read source files and write tests without calling `generate_test` first. Do not skip MCP tools because you think you can do it faster. The MCP tools are mandatory for all test workflows.

## MCP tools

| Tool | When to use |
|------|-------------|
| `run_tests` | Execute tests (Jest, Vitest, pytest, .NET, custom). Set `include_coverage=true` to measure coverage. |
| `generate_test` | Get guidance for creating/improving tests for a **single** source file. **Must be called first** — never skip it. |
| `generate_tests_batch` | Scan a **folder** to find source files that need tests. |
| `inspect_coverage` | Read existing coverage artifacts without re-running tests. |
| `find_test_files` | Discover test files in a directory. |

## Rules

1. **Do NOT modify source code** — only create or update test files. If source code changes seem needed, ask the user first.
2. **Preserve existing assertions** — only add or refine, never remove.
3. **`generate_test` is mandatory** for every file's test creation/improvement. Do not skip it for speed, convenience, or because you can write tests directly. If it is unavailable (MCP server not started), **STOP** and ask the user to enable Unit Test MCP tools and reload VS Code. Do not fall back to manual test authoring.

## Workflow

### 1. Determine the intent

- **Run tests:** Call `run_tests` immediately (see Execution Rules below for parameters).
- **Run tests + inspect coverage:** Call `run_tests` with `include_coverage=true`, then call `inspect_coverage` with the same `root_dir`.
- **Run tests with coverage (no explicit inspect request):** Call `run_tests` with `include_coverage=true`. If `coverage.met` is `false`, call `inspect_coverage` automatically. Do not offer coverage work as optional when a coverage target applies.
- **Create tests for a single file:** Call `generate_test` **immediately as your first action**. Do NOT read the source or test file first (exception: Python — brief `file_search` to check test folder layout is OK). Detection: request mentions a specific file with extension (e.g., `user.ts`, `service.py`).
- **Improve an existing test file:** Call `generate_test` with both `source_file_path` and `test_file_path`. Do NOT read the test file before calling. Apply additive improvements only.
- **Create tests for a folder/multiple files:** Call `generate_tests_batch` first, then process files **one at a time** using this strict cycle:

  **For EACH file (do NOT batch all generate_test calls together):**
  1. Call `generate_test` for this file
  2. Read the source file
  3. Create or update **a dedicated test file for this source file** (one test file per source file — do not combine tests for multiple source files into a single test file)
  4. Run `get_errors` and fix any issues
  5. Run tests via `run_tests` — tests **must pass** before moving on
  6. **Only then** move to the next file and repeat from step 1

  Do NOT call `generate_test` for all files first and then write all tests afterward. Each file must complete its full cycle before starting the next.
- **Inspect coverage only:** Call `inspect_coverage` immediately. Do not re-run tests.

### 2. Framework detection

Inspect the nearest `package.json` (JS/TS) or project config to choose the framework parameter:
- **Jest**: `framework=jest` — test script/deps reference jest
- **Vitest**: `framework=vitest` — test script/deps reference vitest
- **pytest**: `framework=pytest`, `language=python`
- **.NET**: `framework=dotnet`, `language=csharp`
- **Other** (Karma, Mocha, AVA, etc.): `framework=custom`

Use the repo's existing test location conventions (`__tests__`, `tests/`, colocated) rather than forcing a structure.

### 3. After `generate_test` returns

`generate_test` returns guidance, not finished code — do **not** paste its raw output back to the user. You must:
1. Read the source file to understand logic, inputs, and expected outputs.
2. Synthesize concrete test code from the guidance.
3. Create or update the test file (additive edits only if it exists).
4. Run `get_errors` and iteratively fix **all** lint/compile errors until none remain. Do this **before** proceeding.
5. Run tests via `run_tests` with `include_coverage=true` and continue improving tests until target coverage is met for the requested scope.
6. Do **not** end with “Want me to add coverage-focused tests?” when coverage is below target — coverage completion is required before reporting done.

**Path heuristics:** To find the test file from source, examine the repo's existing test structure (`__tests__`, `tests/`, colocated). To find the source from a test file, remove `.test.`/`.spec.`, move out of `__tests__` (JS/TS), `tests/` (Python), or remove `Tests` suffix (C#).

### 4. Test execution rules

- `root_dir`: The directory you would `cd` into to run tests manually. Prefer **absolute paths** on Windows.
  - **Jest/Vitest**: folder with `package.json` (verify it has test config).
  - **.NET**: folder with `.sln` or `.csproj`.
  - **Python**: folder with `pytest.ini`, `pyproject.toml`, `tox.ini`, or `setup.cfg`.
- **`test_pattern`**: Prefer explicit test file paths (e.g., `tests/test_foo.py`, `src/__tests__/utils.test.ts`) over bare keyword stems for deterministic targeting and accurate per-file coverage.
- **Timeouts**: Pass `timeout_ms` for long runs (suggested: 600000 for coverage).
- **Custom frameworks**: Pass `framework=custom`; configure via `unittestMcp.customCommand` setting.

### 5. Coverage improvement loop

Do NOT report task completion until coverage for the requested scope meets the configured target (from MCP settings/tool response).

**Important:** When testing a single file, `coverage.met` may report `false` because it can reflect repo-wide coverage. In that case, use per-file coverage for the target source file and compare it to the configured target percentage. Do NOT call `inspect_coverage` after a single-file test run unless the user explicitly asks.

```
REPEAT (max 5 iterations):
  1. Run tests with include_coverage=true
  2. If coverage meets configured target for the requested scope → done
  3. Else:
     a. Call inspect_coverage to find uncovered lines/branches
     b. Read the source at those lines to understand uncovered paths
     c. Write new tests targeting those paths
     d. Fix any lint/compile errors (get_errors)
     e. Go to step 1
```

- Track coverage per file separately.
- Focus on: error handling, early returns, conditional branches, catch blocks.
- After 5 iterations without meeting target, report current coverage and remaining uncovered paths.
- If uncovered code is unreachable, explain why and suggest alternatives.

### 6. `inspect_coverage` rules

- Use to read existing artifacts — do NOT re-run tests just to see coverage.
- Always pass `root_dir` and `framework`.
- Supports: Istanbul JSON, LCOV, Cobertura XML, OpenCover XML, coverage.py JSON.
- Interpret the trimmed per-file data directly to identify low-coverage files.

### 7. General rules

- If 3 consecutive test runs fail, re-read config and retry once.
- If source path inference fails, ask the user.
- If tools are unavailable, suggest reloading VS Code.
